# TODO: most likely it makes more sense to fold this in, create a wrapper method around SchemaToNickel so that it defines the prelim there for all generated text
# Also this wrapper should handle the complex shenanigen
let k8sSchema = import "k8s.json" in
let rec jsonSchema =
  (import "schema.ncl")
  & {
    DefaultAdditionalProperties = false,
    GetRef = fun ref =>
      let ref = std.string.split "/" ref in
      ref
      |> match {
        ["#", "definitions", ..rest] => std.trace "ref %{std.array.first rest}" std.array.first rest,
        ["#", "defs", ..rest] => std.array.first rest
      },
  }
in
let result =
  k8sSchema.definitions
  |> std.record.to_array
  # |> std.array.filter (fun e => std.record.has_field "x-kubernetes-group-version-kind" e.value)
  # |> std.array.filter (fun e => !std.string.contains "io.k8s.apiextensions-apiserver.pkg.apis.apiextensions.v1" e.field)
  # |> std.array.filter (fun e => std.string.contains "io.k8s.api.apps.v1" e.field)
  |> std.array.fold_right
    (
      fun e acc =>
        let field =
          if std.record.has_field "x-kubernetes-group-version-kind" e.value && (std.array.length e.value.x-kubernetes-group-version-kind == 1) then
            let groupDef = std.array.first e.value.x-kubernetes-group-version-kind in
            let group =
              if groupDef.group == "" then
                ""
              else
                groupDef.group ++ "."
            in group ++ groupDef.version ++ "." ++ groupDef.kind
          else
            e.field
        in
        # BUG: this is not evaluation correctly when we attempt to merge additional properties before evaluating the full schema for an api
        # Somehow it reaches the base method with a bool for some types
        std.trace "evaluating api %{field}" (acc ++ "%{field} \n = %{jsonSchema.SchemaToNickel e.value false},\n")
    )
    m%"# DO NOT EDIT THIS FILE MANUALLY
        # Auto Generated Contracts
let lib = import "Contracts.ncl" in
      {"%
in result ++ "\n}"
