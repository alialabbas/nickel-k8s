# TODO: most likely it makes more sense to fold this in, create a wrapper method around SchemaToNickel so that it defines the prelim there for all generated text
# Also this wrapper should handle the complex shenanigen
let k8sSchema = import "swagger.json" in
let rec jsonSchema =
  (import "schema.ncl")
  & {
    DefaultAdditionalProperties = false,
    GetRef = fun ref =>
      let ref = std.string.split "/" ref in
      ref
      |> match {
        ["#", "definitions", ..rest] => std.trace "ref %{std.array.first rest}" std.array.first rest,
        ["#", "defs", ..rest] => std.array.first rest
      },
  }
in
# "io.k8s.apimachinery.pkg.util.intstr.IntOrString": {
#   "description": "IntOrString is a type that can hold an int32 or a string.  When used in JSON or YAML marshalling and unmarshalling, it produces or consumes the inner type.  This allows you to have, for example, a JSON field that can accept a name or number.",
#   "format": "int-or-string",
#   "type": "string"
# },
# Kubernetes schema is so bad, this IntOrString is not really a string or int but rather just a string
# here we patch to allow us to get the correct one_of [String, Number] contract
let k8sSchema =
  std.record.update
    "definitions"
    (
      std.record.update
        "io.k8s.apimachinery.pkg.util.intstr.IntOrString"
        {
          oneOf = [
            {
              type = "number",
            },
            {
              type = "string",
            },
          ],
        }
        k8sSchema.definitions
    )
    k8sSchema
in
let result =
  k8sSchema.definitions
  |> std.record.to_array
  # |> std.array.filter (fun e => std.record.has_field "x-kubernetes-group-version-kind" e.value)
  # |> std.array.filter (fun e => !std.string.contains "io.k8s.apiextensions-apiserver.pkg.apis.apiextensions.v1" e.field)
  # |> std.array.filter (fun e => std.string.contains "io.k8s.api.apps.v1" e.field)
  |> std.array.fold_right
    (
      fun e acc =>
        let field =
          if std.record.has_field "x-kubernetes-group-version-kind" e.value && (std.array.length e.value.x-kubernetes-group-version-kind == 1) then
            let groupDef = std.array.first e.value.x-kubernetes-group-version-kind in
            let group =
              if groupDef.group == "" then
                ""
              else
                groupDef.group ++ "."
            in group ++ groupDef.version ++ "." ++ groupDef.kind
          else
            e.field
        in
        # TODO: the generation here should populate required fields also for the schema itself
        let schema =
          if std.record.has_field "x-kubernetes-group-version-kind" e.value && (std.array.length e.value.x-kubernetes-group-version-kind == 1) then
            let groupDef = std.array.first e.value.x-kubernetes-group-version-kind in
            # TODO: clean up this mess and try to merge this with crds generation somehow
            let required = (std.record.get_or "required" [] e.value) @ ["kind", "apiVersion"] in
            std.record.update
              "required"
              required
              (
                e.value
                & {
                  properties = {
                    kind = {
                      const = groupDef.kind
                    },
                    apiVersion = {
                      const =
                        if groupDef.group != "" then
                          "%{groupDef.group}/%{groupDef.version}"
                        else
                          "%{groupDef.version}"
                    },
                  },
                }
              )
          else
            e.value
        in
        # BUG: this is not evaluation correctly when we attempt to merge additional properties before evaluating the full schema for an api
        # Somehow it reaches the base method with a bool for some types
        std.trace "evaluating api %{field}" (acc ++ "%{field} \n = %{jsonSchema.SchemaToNickel schema false},\n")
    )
    m%"# DO NOT EDIT THIS FILE MANUALLY
        # Auto Generated Contracts
let lib = import "Contracts.ncl" in
      {"%
in result ++ "\n}"
