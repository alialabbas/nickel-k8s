# TODO: most likely it makes more sense to fold this in, create a wrapper method around SchemaToNickel so that it defines the prelim there for all generated text
# Also this wrapper should handle the complex shenanigen
let rec jsonSchema =
  (import "schema.ncl")
  & {
    DefaultAdditionalProperties = false,
    GetRef = fun ref =>
      let ref = std.string.split "/" ref in
      ref
      |> match {
        ["#", "definitions", ..rest] => std.array.first rest,
        ["#", "defs", ..rest] => std.array.first rest
      },
  }
in
{
  # TODO: schema typing here PLEASE
  Input | default = {}, # | { definitions | { _ | Dyn }, .. } | default = { definitions = {}, },
  Output =
    let k8sSchema =
      # Kubernetes schema is so bad, this IntOrString is not really a string or int but rather just a string
      # here we patch to allow us to get the correct one_of [String, Number] contract
      std.record.update
        "definitions"
        (
          std.record.update
            "io.k8s.apimachinery.pkg.util.intstr.IntOrString"
            {
              oneOf = [
                {
                  type = "number",
                },
                {
                  type = "string",
                },
              ],
            }
          # can't use dot notations here else the type checker would complain
          (std.record.get_or "definitions" {} Input)
            # Input.definitions
        )
        Input
    in
    (
      k8sSchema.definitions
      |> std.record.to_array
      |> std.array.fold_right
        (fun e acc =>
          let field =
            if std.record.has_field "x-kubernetes-group-version-kind" e.value && (std.array.length e.value.x-kubernetes-group-version-kind == 1) then
              let groupDef = std.array.first e.value.x-kubernetes-group-version-kind in
              if groupDef.group == "" then
                groupDef.version ++ "." ++ groupDef.kind
              else
                "\"%{groupDef.group}\"." ++ groupDef.version ++ "." ++ groupDef.kind
            else
              e.field
          in
          # TODO: the generation here should populate required fields also for the schema itself
          let schema =
            if std.record.has_field "x-kubernetes-group-version-kind" e.value && (std.array.length e.value.x-kubernetes-group-version-kind == 1) then
              let groupDef = std.array.first e.value.x-kubernetes-group-version-kind in
              # TODO: clean up this mess and try to merge this with crds generation somehow
              let required = (std.record.get_or "required" [] e.value) @ ["kind", "apiVersion"] in
              std.record.update
                "required"
                required
                (
                  e.value
                  & {
                    properties = {
                      kind = {
                        const = groupDef.kind
                      },
                      apiVersion = {
                        const =
                          if groupDef.group != "" then
                            "%{groupDef.group}/%{groupDef.version}"
                          else
                            "%{groupDef.version}"
                      },
                    },
                  }
                )
            else
              e.value
          in
          # BUG: this is not evaluation correctly when we attempt to merge additional properties before evaluating the full schema for an api
          # Somehow it reaches the base method with a bool for some types
          (acc ++ "%{field} \n = %{jsonSchema.SchemaToNickel schema false},\n")
        )
        m%"# DO NOT EDIT THIS FILE MANUALLY
        # Auto Generated Contracts
let lib = import "lib.ncl" in
      {"%
    )
    ++ "\n}",
}
