let k8sSchema = import "swagger.json" in
let rec k =
  (import "k8s.ncl")
  & {

    ArrayConversion
      = fun schema =>
        let arrayType =
          # TODO: This should check if items exist
          let items = std.typeof (std.record.get_or "items" false schema) in
          items
          |> match {
            '"Bool" => k.SchemaToNickel {} false, # TODO: Technically this will yield wrong type when there is only type array and items is false but it doesn't make sense to have an empty array as value from a schema
            '"Record" => k.SchemaToNickel schema.items false,
          }
        in
        let mergeKey = std.record.get_or "x-kubernetes-patch-merge-key" "" schema in
        if mergeKey != "" && arrayType != "" then
          m%"{ _ | %{arrayType} } | lib.FromMapToList "%{mergeKey}""%
        else if mergeKey != "" then
          m%"lib.FromMapToList "%{mergeKey}""%
        else
          arrayType,
    GetRef = (
      fun ref =>
        let ref = std.string.split "/" ref in
        ref
        |> match {
          ["#", "definitions", ..rest] => std.trace "in hereref" k.SchemaToNickel k8sSchema.definitions."%{std.array.first rest}" false,
          # ["#", "defs", ..rest] => std.array.first rest
        }
    )
  }
in

let result =
  k8sSchema.definitions
  |> std.record.to_array
  |> std.array.filter (fun e => std.record.has_field "x-kubernetes-group-version-kind" e.value)
  |> std.array.filter (fun e => !std.string.contains "io.k8s.apiextensions-apiserver.pkg.apis.apiextensions.v1" e.field)
  # |> std.array.filter (fun e => std.string.contains "io.k8s.api.apps.v1" e.field)
  |> std.array.fold_right
    (
      fun e acc =>
        let field =
          if std.record.has_field "x-kubernetes-group-version-kind" e.value && (std.array.length e.value.x-kubernetes-group-version-kind == 1) then
            let groupDef = std.array.first e.value.x-kubernetes-group-version-kind in
            let group =
              if groupDef.group == "" then
                ""
              else
                groupDef.group ++ "."
            in group ++ groupDef.version ++ "." ++ groupDef.kind
          else
            e.field
        in
        # BUG: this is not evaluation correctly when we attempt to merge additional properties before evaluating the full schema for an api
        # Somehow it reaches the base method with a bool for some types
        let schema = k.SchemaToNickel e.value false in
        if schema != "" then
          std.trace "evaluating api %{field}" (acc ++ "%{field} \n = %{schema},\n")
        else
          acc
    )
    m%"# DO NOT EDIT THIS FILE MANUALLY
        # Auto Generated Contracts
let lib = import "Contracts.ncl" in
      {"%
in result ++ "\n}"
